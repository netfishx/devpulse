// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: summary.sql

package dbgen

import (
	"context"
	"encoding/json"

	"github.com/jackc/pgx/v5/pgtype"
)

const aggregateDailySummary = `-- name: AggregateDailySummary :one
SELECT
    count(*) FILTER (WHERE type = 'push')::int AS total_commits,
    count(*) FILTER (WHERE type = 'pull_request')::int AS total_prs
FROM activities
WHERE user_id = $1
  AND occurred_at >= $2::timestamptz
  AND occurred_at < $3::timestamptz
`

type AggregateDailySummaryParams struct {
	UserID  int64              `json:"user_id"`
	Column2 pgtype.Timestamptz `json:"column_2"`
	Column3 pgtype.Timestamptz `json:"column_3"`
}

type AggregateDailySummaryRow struct {
	TotalCommits int32 `json:"total_commits"`
	TotalPrs     int32 `json:"total_prs"`
}

func (q *Queries) AggregateDailySummary(ctx context.Context, arg AggregateDailySummaryParams) (AggregateDailySummaryRow, error) {
	row := q.db.QueryRow(ctx, aggregateDailySummary, arg.UserID, arg.Column2, arg.Column3)
	var i AggregateDailySummaryRow
	err := row.Scan(&i.TotalCommits, &i.TotalPrs)
	return i, err
}

const listSummariesByUser = `-- name: ListSummariesByUser :many
SELECT id, user_id, date, total_commits, total_prs, coding_minutes, top_repos, top_languages
FROM daily_summaries
WHERE user_id = $1
  AND date >= CURRENT_DATE - $2::int
ORDER BY date DESC
`

type ListSummariesByUserParams struct {
	UserID  int64 `json:"user_id"`
	Column2 int32 `json:"column_2"`
}

func (q *Queries) ListSummariesByUser(ctx context.Context, arg ListSummariesByUserParams) ([]DailySummary, error) {
	rows, err := q.db.Query(ctx, listSummariesByUser, arg.UserID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DailySummary{}
	for rows.Next() {
		var i DailySummary
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Date,
			&i.TotalCommits,
			&i.TotalPrs,
			&i.CodingMinutes,
			&i.TopRepos,
			&i.TopLanguages,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertDailySummary = `-- name: UpsertDailySummary :exec
INSERT INTO daily_summaries (user_id, date, total_commits, total_prs, coding_minutes, top_repos, top_languages)
VALUES ($1, $2, $3, $4, $5, $6, $7)
ON CONFLICT (user_id, date)
DO UPDATE SET
    total_commits = EXCLUDED.total_commits,
    total_prs = EXCLUDED.total_prs,
    coding_minutes = EXCLUDED.coding_minutes,
    top_repos = EXCLUDED.top_repos,
    top_languages = EXCLUDED.top_languages
`

type UpsertDailySummaryParams struct {
	UserID        int64           `json:"user_id"`
	Date          pgtype.Date     `json:"date"`
	TotalCommits  pgtype.Int4     `json:"total_commits"`
	TotalPrs      pgtype.Int4     `json:"total_prs"`
	CodingMinutes pgtype.Int4     `json:"coding_minutes"`
	TopRepos      json.RawMessage `json:"top_repos"`
	TopLanguages  json.RawMessage `json:"top_languages"`
}

func (q *Queries) UpsertDailySummary(ctx context.Context, arg UpsertDailySummaryParams) error {
	_, err := q.db.Exec(ctx, upsertDailySummary,
		arg.UserID,
		arg.Date,
		arg.TotalCommits,
		arg.TotalPrs,
		arg.CodingMinutes,
		arg.TopRepos,
		arg.TopLanguages,
	)
	return err
}
