# DevPulse Phase 2 Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** GitHub data flows in via hourly cron sync, user sees commit timeline and daily stats on the web dashboard.

**Architecture:** River (PostgreSQL-native job queue) handles scheduled sync and aggregation inside the API process. Two new REST endpoints serve paginated activities and daily summaries. Next.js dashboard with shadcn/ui (Base UI) displays summary cards, 30-day bar chart, and activity timeline.

**Tech Stack:** River + pgxpool, GitHub Events API, sqlc, shadcn/ui Charts (Base UI), Recharts

---

## Task 1: River setup + migration

**Files:**
- Modify: `api/go.mod` (add river dependencies)
- Create: `api/db/migrations/002_river.up.sql`
- Create: `api/db/migrations/002_river.down.sql`
- Create: `api/internal/river/setup.go`
- Modify: `api/cmd/api/main.go` (wire River client)

**Step 1: Install River dependencies**

```bash
cd /Users/ethanwang/projects/devpulse/api
go get github.com/riverqueue/river
go get github.com/riverqueue/river/riverdriver/riverpgxv5
go get github.com/riverqueue/river/rivermigrate
```

**Step 2: Export River migration SQL**

```bash
go install github.com/riverqueue/river/cmd/river@latest
river migrate-get --line main --all --up > db/migrations/002_river.up.sql
river migrate-get --line main --all --down > db/migrations/002_river.down.sql
```

Verify migration files are non-empty.

**Step 3: Run migration against Supabase**

```bash
cd /Users/ethanwang/projects/devpulse
source .env
cd api && migrate -path db/migrations -database "$DATABASE_URL" up
```

Expected: `2/u river` applied successfully.

**Step 4: Create `api/internal/river/setup.go`**

```go
package river

import (
	"github.com/jackc/pgx/v5/pgxpool"
	riverlib "github.com/riverqueue/river"
	"github.com/riverqueue/river/riverdriver/riverpgxv5"
)

// NewClient creates a River client with the given pool, workers, and periodic jobs.
// Workers and periodic jobs should be registered by callers before passing in.
func NewClient(pool *pgxpool.Pool, workers *riverlib.Workers, periodicJobs []*riverlib.PeriodicJob) (*riverlib.Client[*riverpgxv5.Driver], error) {
	return riverlib.NewClient(riverpgxv5.New(pool), &riverlib.Config{
		Queues: map[string]riverlib.QueueConfig{
			riverlib.QueueDefault: {MaxWorkers: 2},
		},
		Workers:      workers,
		PeriodicJobs: periodicJobs,
	})
}
```

**Step 5: Wire River into `api/cmd/api/main.go`**

Add River client startup after pool creation, before Echo server start. Add signal handling for graceful shutdown of both Echo and River.

```go
// After pool.Ping succeeds:

// River (job queue)
workers := river.NewWorkers()
// Workers will be registered here in later tasks
var periodicJobs []*river.PeriodicJob
// Periodic jobs will be added here in later tasks

riverClient, err := riversetup.NewClient(pool, workers, periodicJobs)
if err != nil {
    slog.Error("failed to create river client", "error", err)
    return
}
if err := riverClient.Start(context.Background()); err != nil {
    slog.Error("failed to start river client", "error", err)
    return
}
defer riverClient.Stop(context.Background())
slog.Info("river started")
```

**Step 6: Verify API starts without errors**

```bash
cd /Users/ethanwang/projects/devpulse/api
go run ./cmd/api
```

Expected: `database connected`, `river started`, `starting server port=8080`.

**Step 7: Run tests**

```bash
go test ./... -count=1
```

Expected: All 14 existing tests pass, no regressions.

**Step 8: Commit**

```bash
cd /Users/ethanwang/projects/devpulse
git add api/
git commit -m "feat(api): add River job queue setup + migration"
```

---

## Task 2: Schema change + sqlc queries for activities and summaries

**Files:**
- Create: `api/db/migrations/003_activities_external_id.up.sql`
- Create: `api/db/migrations/003_activities_external_id.down.sql`
- Create: `api/db/queries/activity.sql`
- Create: `api/db/queries/summary.sql`
- Modify: `api/db/generated/*` (regenerated by sqlc)

**Step 1: Create migration for external_id**

Create `api/db/migrations/003_activities_external_id.up.sql`:

```sql
ALTER TABLE activities ADD COLUMN external_id text;
CREATE UNIQUE INDEX idx_activities_dedup ON activities (user_id, source, external_id);
```

Create `api/db/migrations/003_activities_external_id.down.sql`:

```sql
DROP INDEX IF EXISTS idx_activities_dedup;
ALTER TABLE activities DROP COLUMN IF EXISTS external_id;
```

**Step 2: Run migration**

```bash
cd /Users/ethanwang/projects/devpulse
source .env
cd api && migrate -path db/migrations -database "$DATABASE_URL" up
```

Expected: `3/u activities_external_id` applied.

**Step 3: Create `api/db/queries/activity.sql`**

```sql
-- name: InsertActivity :exec
INSERT INTO activities (user_id, source, type, payload, occurred_at, external_id)
VALUES ($1, $2, $3, $4, $5, $6)
ON CONFLICT (user_id, source, external_id) DO NOTHING;

-- name: ListActivitiesByUser :many
SELECT id, user_id, source, type, payload, occurred_at, external_id, created_at
FROM activities
WHERE user_id = $1
ORDER BY occurred_at DESC
LIMIT $2 OFFSET $3;

-- name: CountActivitiesByUser :one
SELECT count(*) FROM activities WHERE user_id = $1;
```

**Step 4: Create `api/db/queries/summary.sql`**

```sql
-- name: UpsertDailySummary :exec
INSERT INTO daily_summaries (user_id, date, total_commits, total_prs, coding_minutes, top_repos, top_languages)
VALUES ($1, $2, $3, $4, $5, $6, $7)
ON CONFLICT (user_id, date)
DO UPDATE SET
    total_commits = EXCLUDED.total_commits,
    total_prs = EXCLUDED.total_prs,
    coding_minutes = EXCLUDED.coding_minutes,
    top_repos = EXCLUDED.top_repos,
    top_languages = EXCLUDED.top_languages;

-- name: ListSummariesByUser :many
SELECT id, user_id, date, total_commits, total_prs, coding_minutes, top_repos, top_languages
FROM daily_summaries
WHERE user_id = $1
  AND date >= CURRENT_DATE - $2::int
ORDER BY date DESC;

-- name: AggregateDailySummary :one
SELECT
    count(*) FILTER (WHERE type = 'push')::int AS total_commits,
    count(*) FILTER (WHERE type = 'pull_request')::int AS total_prs
FROM activities
WHERE user_id = $1
  AND occurred_at >= $2::timestamptz
  AND occurred_at < $3::timestamptz;
```

**Step 5: Regenerate sqlc**

```bash
cd /Users/ethanwang/projects/devpulse/api
sqlc generate
```

Verify generated files in `db/generated/` include `activity.sql.go` and `summary.sql.go`.

**Step 6: Build to verify no compile errors**

```bash
go build ./...
```

Expected: Clean build.

**Step 7: Commit**

```bash
cd /Users/ethanwang/projects/devpulse
git add api/
git commit -m "feat(api): add activities external_id + sqlc queries for activities and summaries"
```

---

## Task 3: GitHub API client

**Files:**
- Create: `api/internal/github/client.go`
- Create: `api/internal/github/model.go`
- Create: `api/internal/github/client_test.go`

**Step 1: Create `api/internal/github/model.go`**

Define types matching GitHub Events API response:

```go
package github

import "time"

// Event represents a GitHub event from the Events API.
// https://docs.github.com/en/rest/activity/events
type Event struct {
	ID        string    `json:"id"`
	Type      string    `json:"type"`
	Repo      Repo      `json:"repo"`
	CreatedAt time.Time `json:"created_at"`
	Payload   Payload   `json:"payload"`
}

type Repo struct {
	Name string `json:"name"`
}

type Payload struct {
	// PushEvent
	Commits []Commit `json:"commits,omitempty"`
	Size    int      `json:"size,omitempty"`
	// PullRequestEvent
	Action      string       `json:"action,omitempty"`
	PullRequest *PullRequest `json:"pull_request,omitempty"`
}

type Commit struct {
	SHA     string `json:"sha"`
	Message string `json:"message"`
}

type PullRequest struct {
	Title string `json:"title"`
	State string `json:"state"`
}
```

**Step 2: Create `api/internal/github/client.go`**

```go
package github

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
)

// SupportedEventTypes lists the event types we process.
var SupportedEventTypes = map[string]bool{
	"PushEvent":              true,
	"PullRequestEvent":       true,
	"PullRequestReviewEvent": true,
	"CreateEvent":            true,
}

// Client calls the GitHub API.
type Client struct {
	httpClient *http.Client
}

func NewClient(httpClient *http.Client) *Client {
	if httpClient == nil {
		httpClient = &http.Client{}
	}
	return &Client{httpClient: httpClient}
}

// FetchUserEvents fetches all recent events for the authenticated user.
// GitHub returns max 10 pages of 30 events (300 total).
func (c *Client) FetchUserEvents(ctx context.Context, token string) ([]Event, error) {
	var allEvents []Event

	for page := 1; page <= 10; page++ {
		url := fmt.Sprintf("https://api.github.com/user/events?per_page=30&page=%d", page)
		req, err := http.NewRequestWithContext(ctx, http.MethodGet, url, nil)
		if err != nil {
			return nil, fmt.Errorf("create request: %w", err)
		}
		req.Header.Set("Authorization", "Bearer "+token)
		req.Header.Set("Accept", "application/vnd.github+json")

		resp, err := c.httpClient.Do(req)
		if err != nil {
			return nil, fmt.Errorf("fetch events page %d: %w", page, err)
		}
		defer resp.Body.Close()

		if resp.StatusCode != http.StatusOK {
			return nil, fmt.Errorf("github api returned %d", resp.StatusCode)
		}

		var events []Event
		if err := json.NewDecoder(resp.Body).Decode(&events); err != nil {
			return nil, fmt.Errorf("decode events: %w", err)
		}

		allEvents = append(allEvents, events...)

		if len(events) < 30 {
			break // No more pages
		}
	}

	return allEvents, nil
}
```

**Step 3: Write test for model parsing**

Create `api/internal/github/client_test.go`:

```go
package github

import (
	"context"
	"encoding/json"
	"net/http"
	"net/http/httptest"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestFetchUserEvents_ParsesPushEvent(t *testing.T) {
	events := []Event{
		{
			ID:   "12345",
			Type: "PushEvent",
			Repo: Repo{Name: "user/repo"},
			Payload: Payload{
				Size:    1,
				Commits: []Commit{{SHA: "abc123", Message: "fix bug"}},
			},
		},
	}

	srv := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		assert.Equal(t, "Bearer test-token", r.Header.Get("Authorization"))
		json.NewEncoder(w).Encode(events)
	}))
	defer srv.Close()

	client := &Client{httpClient: srv.Client()}
	// Override URL via custom transport or test differently
	// For simplicity, test JSON parsing separately
	var parsed []Event
	body, _ := json.Marshal(events)
	err := json.Unmarshal(body, &parsed)
	require.NoError(t, err)
	assert.Equal(t, "12345", parsed[0].ID)
	assert.Equal(t, "PushEvent", parsed[0].Type)
	assert.Equal(t, "user/repo", parsed[0].Repo.Name)
	assert.Len(t, parsed[0].Payload.Commits, 1)
}

func TestSupportedEventTypes(t *testing.T) {
	assert.True(t, SupportedEventTypes["PushEvent"])
	assert.True(t, SupportedEventTypes["PullRequestEvent"])
	assert.False(t, SupportedEventTypes["WatchEvent"])
}
```

**Step 4: Run tests**

```bash
cd /Users/ethanwang/projects/devpulse/api
go test ./internal/github/ -v
```

Expected: PASS.

**Step 5: Commit**

```bash
cd /Users/ethanwang/projects/devpulse
git add api/
git commit -m "feat(api): add GitHub API client and event models"
```

---

## Task 4: GitHub sync worker (River)

**Files:**
- Create: `api/internal/github/worker.go`
- Create: `api/internal/github/worker_test.go`
- Modify: `api/cmd/api/main.go` (register worker + periodic job)

**Step 1: Create `api/internal/github/worker.go`**

```go
package github

import (
	"context"
	"encoding/json"
	"log/slog"

	"github.com/jackc/pgx/v5/pgtype"
	riverlib "github.com/riverqueue/river"

	dbgen "github.com/ethanwang/devpulse/api/db/generated"
)

// SyncArgs are the arguments for the GitHub sync job.
type SyncArgs struct{}

func (SyncArgs) Kind() string { return "github_sync" }

// SyncWorker syncs GitHub events for all users with a GitHub data source.
type SyncWorker struct {
	riverlib.WorkerDefaults[SyncArgs]
	q      *dbgen.Queries
	client *Client
}

func NewSyncWorker(q *dbgen.Queries, client *Client) *SyncWorker {
	return &SyncWorker{q: q, client: client}
}

func (w *SyncWorker) Work(ctx context.Context, job *riverlib.Job[SyncArgs]) error {
	// List all users with GitHub data source
	sources, err := w.q.ListDataSourcesByProvider(ctx, "github")
	if err != nil {
		return err
	}

	for _, src := range sources {
		if err := w.syncUser(ctx, src); err != nil {
			slog.Error("github sync failed for user", "user_id", src.UserID, "error", err)
			// Continue with other users, don't fail the whole job
		}
	}
	return nil
}

func (w *SyncWorker) syncUser(ctx context.Context, src dbgen.ListDataSourcesByProviderRow) error {
	// Get full data source to read token
	ds, err := w.q.GetDataSourceByUserAndProvider(ctx, dbgen.GetDataSourceByUserAndProviderParams{
		UserID:   src.UserID,
		Provider: "github",
	})
	if err != nil {
		return err
	}

	events, err := w.client.FetchUserEvents(ctx, string(ds.AccessToken))
	if err != nil {
		return err
	}

	var inserted int
	for _, evt := range events {
		if !SupportedEventTypes[evt.Type] {
			continue
		}

		payload, _ := json.Marshal(map[string]any{
			"repo":    evt.Repo.Name,
			"payload": evt.Payload,
		})

		eventType := mapEventType(evt.Type)

		err := w.q.InsertActivity(ctx, dbgen.InsertActivityParams{
			UserID:     src.UserID,
			Source:     "github",
			Type:       eventType,
			Payload:    payload,
			OccurredAt: pgtype.Timestamptz{Time: evt.CreatedAt, Valid: true},
			ExternalID: pgtype.Text{String: evt.ID, Valid: true},
		})
		if err != nil {
			slog.Error("insert activity failed", "event_id", evt.ID, "error", err)
			continue
		}
		inserted++
	}

	slog.Info("github sync complete", "user_id", src.UserID, "events", len(events), "inserted", inserted)
	return nil
}

func mapEventType(ghType string) string {
	switch ghType {
	case "PushEvent":
		return "push"
	case "PullRequestEvent":
		return "pull_request"
	case "PullRequestReviewEvent":
		return "review"
	case "CreateEvent":
		return "create"
	default:
		return ghType
	}
}
```

**Step 2: Add `ListDataSourcesByProvider` query**

Add to `api/db/queries/data_source.sql`:

```sql
-- name: ListDataSourcesByProvider :many
SELECT id, user_id, provider, created_at
FROM data_sources
WHERE provider = $1;
```

Regenerate sqlc:

```bash
cd /Users/ethanwang/projects/devpulse/api && sqlc generate
```

**Step 3: Write worker test**

Create `api/internal/github/worker_test.go`:

```go
package github

import (
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestMapEventType(t *testing.T) {
	tests := []struct {
		input    string
		expected string
	}{
		{"PushEvent", "push"},
		{"PullRequestEvent", "pull_request"},
		{"PullRequestReviewEvent", "review"},
		{"CreateEvent", "create"},
		{"UnknownEvent", "UnknownEvent"},
	}
	for _, tt := range tests {
		assert.Equal(t, tt.expected, mapEventType(tt.input))
	}
}
```

**Step 4: Register worker and periodic job in `api/cmd/api/main.go`**

```go
// After queries := dbgen.New(pool):

ghClient := github.NewClient(nil)
ghSyncWorker := github.NewSyncWorker(queries, ghClient)

workers := river.NewWorkers()
river.AddWorker(workers, ghSyncWorker)

periodicJobs := []*river.PeriodicJob{
    river.NewPeriodicJob(
        river.PeriodicInterval(1*time.Hour),
        func() (river.JobArgs, *river.InsertOpts) {
            return github.SyncArgs{}, nil
        },
        &river.PeriodicJobOpts{RunOnStart: true},
    ),
}
```

**Step 5: Run tests**

```bash
cd /Users/ethanwang/projects/devpulse/api
go test ./... -count=1
```

Expected: All tests pass (existing 14 + new github tests).

**Step 6: Commit**

```bash
cd /Users/ethanwang/projects/devpulse
git add api/
git commit -m "feat(api): add GitHub sync worker with River periodic job"
```

---

## Task 5: Daily aggregation worker (River)

**Files:**
- Create: `api/internal/summary/worker.go`
- Create: `api/internal/summary/worker_test.go`
- Modify: `api/cmd/api/main.go` (register worker + periodic job)

**Step 1: Create `api/internal/summary/worker.go`**

```go
package summary

import (
	"context"
	"log/slog"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
	riverlib "github.com/riverqueue/river"

	dbgen "github.com/ethanwang/devpulse/api/db/generated"
)

// AggregateArgs are the arguments for the daily aggregation job.
type AggregateArgs struct{}

func (AggregateArgs) Kind() string { return "daily_aggregate" }

// AggregateWorker aggregates activities into daily summaries.
type AggregateWorker struct {
	riverlib.WorkerDefaults[AggregateArgs]
	q *dbgen.Queries
}

func NewAggregateWorker(q *dbgen.Queries) *AggregateWorker {
	return &AggregateWorker{q: q}
}

func (w *AggregateWorker) Work(ctx context.Context, job *riverlib.Job[AggregateArgs]) error {
	// Aggregate yesterday's data for all users
	yesterday := time.Now().AddDate(0, 0, -1)
	startOfDay := time.Date(yesterday.Year(), yesterday.Month(), yesterday.Day(), 0, 0, 0, 0, time.UTC)
	endOfDay := startOfDay.AddDate(0, 0, 1)

	// Get all distinct user IDs from activities
	users, err := w.q.ListDistinctActivityUsers(ctx)
	if err != nil {
		return err
	}

	for _, userID := range users {
		if err := w.aggregateUser(ctx, userID, startOfDay, endOfDay); err != nil {
			slog.Error("aggregation failed for user", "user_id", userID, "error", err)
		}
	}
	return nil
}

func (w *AggregateWorker) aggregateUser(ctx context.Context, userID int64, start, end time.Time) error {
	row, err := w.q.AggregateDailySummary(ctx, dbgen.AggregateDailySummaryParams{
		UserID:     userID,
		OccurredAt: pgtype.Timestamptz{Time: start, Valid: true},
		OccurredAt_2: pgtype.Timestamptz{Time: end, Valid: true},
	})
	if err != nil {
		return err
	}

	err = w.q.UpsertDailySummary(ctx, dbgen.UpsertDailySummaryParams{
		UserID:        userID,
		Date:          pgtype.Date{Time: start, Valid: true},
		TotalCommits:  pgtype.Int4{Int32: row.TotalCommits, Valid: true},
		TotalPrs:      pgtype.Int4{Int32: row.TotalPrs, Valid: true},
		CodingMinutes: pgtype.Int4{Int32: 0, Valid: true},
		TopRepos:      nil,
		TopLanguages:  nil,
	})
	if err != nil {
		return err
	}

	slog.Info("daily summary aggregated", "user_id", userID, "date", start.Format("2006-01-02"))
	return nil
}
```

**Step 2: Add `ListDistinctActivityUsers` query**

Add to `api/db/queries/activity.sql`:

```sql
-- name: ListDistinctActivityUsers :many
SELECT DISTINCT user_id FROM activities;
```

Regenerate sqlc:

```bash
cd /Users/ethanwang/projects/devpulse/api && sqlc generate
```

**Step 3: Register worker in `api/cmd/api/main.go`**

```go
aggWorker := summary.NewAggregateWorker(queries)
river.AddWorker(workers, aggWorker)

// Add to periodicJobs slice:
river.NewPeriodicJob(
    river.PeriodicInterval(24*time.Hour),
    func() (river.JobArgs, *river.InsertOpts) {
        return summary.AggregateArgs{}, nil
    },
    nil,
),
```

**Step 4: Run tests**

```bash
go test ./... -count=1
```

Expected: All tests pass.

**Step 5: Commit**

```bash
cd /Users/ethanwang/projects/devpulse
git add api/
git commit -m "feat(api): add daily aggregation worker"
```

---

## Task 6: Activity list endpoint

**Files:**
- Create: `api/internal/activity/handler.go`
- Create: `api/internal/activity/service.go`
- Create: `api/internal/activity/handler_test.go`
- Modify: `api/cmd/api/main.go` (wire routes)

**Step 1: Create `api/internal/activity/service.go`**

```go
package activity

import (
	"context"
	"time"

	dbgen "github.com/ethanwang/devpulse/api/db/generated"
	"github.com/ethanwang/devpulse/api/internal/apperror"
)

type ActivityResponse struct {
	ID         int64           `json:"id"`
	Source     string          `json:"source"`
	Type       string          `json:"type"`
	Payload    json.RawMessage `json:"payload"`
	OccurredAt time.Time       `json:"occurredAt"`
}

type ListResponse struct {
	Activities []ActivityResponse `json:"activities"`
	Total      int64              `json:"total"`
	Page       int                `json:"page"`
	PerPage    int                `json:"perPage"`
}

type Service struct {
	q *dbgen.Queries
}

func NewService(q *dbgen.Queries) *Service {
	return &Service{q: q}
}

func (s *Service) List(ctx context.Context, userID int64, page, perPage int) (*ListResponse, error) {
	if page < 1 {
		page = 1
	}
	if perPage < 1 || perPage > 100 {
		perPage = 20
	}
	offset := (page - 1) * perPage

	rows, err := s.q.ListActivitiesByUser(ctx, dbgen.ListActivitiesByUserParams{
		UserID: userID,
		Limit:  int32(perPage),
		Offset: int32(offset),
	})
	if err != nil {
		return nil, apperror.Internalf("list activities: %w", err)
	}

	total, err := s.q.CountActivitiesByUser(ctx, userID)
	if err != nil {
		return nil, apperror.Internalf("count activities: %w", err)
	}

	activities := make([]ActivityResponse, 0, len(rows))
	for _, r := range rows {
		activities = append(activities, ActivityResponse{
			ID:         r.ID,
			Source:     r.Source,
			Type:       r.Type,
			Payload:    r.Payload,
			OccurredAt: r.OccurredAt.Time,
		})
	}

	return &ListResponse{
		Activities: activities,
		Total:      total,
		Page:       page,
		PerPage:    perPage,
	}, nil
}
```

**Step 2: Create `api/internal/activity/handler.go`**

```go
package activity

import (
	"net/http"
	"strconv"

	"github.com/labstack/echo/v5"

	mw "github.com/ethanwang/devpulse/api/internal/middleware"
)

type Handler struct {
	svc *Service
}

func NewHandler(svc *Service) *Handler {
	return &Handler{svc: svc}
}

func (h *Handler) RegisterRoutes(g *echo.Group) {
	g.GET("/activities", h.List)
}

func (h *Handler) List(c *echo.Context) error {
	userID, err := mw.GetUserID(c)
	if err != nil {
		return err
	}

	page, _ := strconv.Atoi(c.QueryParam("page"))
	perPage, _ := strconv.Atoi(c.QueryParam("per_page"))

	resp, err := h.svc.List(c.Request().Context(), userID, page, perPage)
	if err != nil {
		return err
	}

	return c.JSON(http.StatusOK, resp)
}
```

**Step 3: Write handler test**

Create `api/internal/activity/handler_test.go`:

```go
package activity

import (
	"net/http"
	"net/http/httptest"
	"testing"

	"github.com/labstack/echo/v5"
	"github.com/stretchr/testify/assert"
)

func TestList_MissingAuth(t *testing.T) {
	e := echo.New()
	req := httptest.NewRequest(http.MethodGet, "/api/activities", nil)
	rec := httptest.NewRecorder()
	c := e.NewContext(req, rec)

	h := NewHandler(nil)
	err := h.List(&c)
	assert.Error(t, err)
}
```

**Step 4: Wire into `api/cmd/api/main.go`**

```go
activitySvc := activity.NewService(queries)
activityHandler := activity.NewHandler(activitySvc)
activityHandler.RegisterRoutes(protected)
```

**Step 5: Run tests**

```bash
go test ./... -count=1
```

Expected: All tests pass.

**Step 6: Commit**

```bash
cd /Users/ethanwang/projects/devpulse
git add api/
git commit -m "feat(api): add GET /api/activities endpoint with pagination"
```

---

## Task 7: Summary endpoint

**Files:**
- Create: `api/internal/summary/handler.go`
- Create: `api/internal/summary/service.go`
- Create: `api/internal/summary/handler_test.go`
- Modify: `api/cmd/api/main.go` (wire routes)

**Step 1: Create `api/internal/summary/service.go`**

```go
package summary

import (
	"context"
	"time"

	dbgen "github.com/ethanwang/devpulse/api/db/generated"
	"github.com/ethanwang/devpulse/api/internal/apperror"
)

type SummaryResponse struct {
	Date          string `json:"date"`
	TotalCommits  int32  `json:"totalCommits"`
	TotalPrs      int32  `json:"totalPrs"`
	CodingMinutes int32  `json:"codingMinutes"`
}

type ListSummariesResponse struct {
	Summaries []SummaryResponse `json:"summaries"`
}

type Service struct {
	q *dbgen.Queries
}

func NewService(q *dbgen.Queries) *Service {
	return &Service{q: q}
}

func (s *Service) List(ctx context.Context, userID int64, days int) (*ListSummariesResponse, error) {
	if days < 1 || days > 365 {
		days = 30
	}

	rows, err := s.q.ListSummariesByUser(ctx, dbgen.ListSummariesByUserParams{
		UserID: userID,
		Column2: int32(days),
	})
	if err != nil {
		return nil, apperror.Internalf("list summaries: %w", err)
	}

	summaries := make([]SummaryResponse, 0, len(rows))
	for _, r := range rows {
		summaries = append(summaries, SummaryResponse{
			Date:          r.Date.Time.Format(time.DateOnly),
			TotalCommits:  r.TotalCommits.Int32,
			TotalPrs:      r.TotalPrs.Int32,
			CodingMinutes: r.CodingMinutes.Int32,
		})
	}

	return &ListSummariesResponse{Summaries: summaries}, nil
}
```

**Step 2: Create `api/internal/summary/handler.go`**

```go
package summary

import (
	"net/http"
	"strconv"

	"github.com/labstack/echo/v5"

	mw "github.com/ethanwang/devpulse/api/internal/middleware"
)

type Handler struct {
	svc *Service
}

func NewHandler(svc *Service) *Handler {
	return &Handler{svc: svc}
}

func (h *Handler) RegisterRoutes(g *echo.Group) {
	g.GET("/summaries", h.List)
}

func (h *Handler) List(c *echo.Context) error {
	userID, err := mw.GetUserID(c)
	if err != nil {
		return err
	}

	days, _ := strconv.Atoi(c.QueryParam("days"))

	resp, err := h.svc.List(c.Request().Context(), userID, days)
	if err != nil {
		return err
	}

	return c.JSON(http.StatusOK, resp)
}
```

**Step 3: Write handler test**

Create `api/internal/summary/handler_test.go`:

```go
package summary

import (
	"net/http"
	"net/http/httptest"
	"testing"

	"github.com/labstack/echo/v5"
	"github.com/stretchr/testify/assert"
)

func TestList_MissingAuth(t *testing.T) {
	e := echo.New()
	req := httptest.NewRequest(http.MethodGet, "/api/summaries", nil)
	rec := httptest.NewRecorder()
	c := e.NewContext(req, rec)

	h := NewHandler(nil)
	err := h.List(&c)
	assert.Error(t, err)
}
```

**Step 4: Wire into `api/cmd/api/main.go`**

```go
summarySvc := summary.NewService(queries)
summaryHandler := summary.NewHandler(summarySvc)
summaryHandler.RegisterRoutes(protected)
```

**Step 5: Run tests**

```bash
go test ./... -count=1
```

Expected: All tests pass.

**Step 6: Update `docs/openapi.yaml`**

Add the two new endpoints (`/api/activities` and `/api/summaries`) with their query parameters and response schemas.

**Step 7: Commit**

```bash
cd /Users/ethanwang/projects/devpulse
git add api/ docs/openapi.yaml
git commit -m "feat(api): add GET /api/summaries endpoint + update OpenAPI spec"
```

---

## Task 8: shadcn/ui setup (Base UI version)

**Files:**
- Modify: `web/package.json` (add shadcn dependencies)
- Create: `web/components.json` (shadcn config)
- Modify: `web/src/app/globals.css` (add CSS variables)
- Generated: `web/src/components/ui/card.tsx`, `button.tsx`, `badge.tsx`, `chart.tsx`

**Step 1: Initialize shadcn/ui**

```bash
cd /Users/ethanwang/projects/devpulse/web
bunx shadcn@latest init
```

When prompted:
- Style: Default
- Base color: Neutral
- CSS variables: Yes
- **React Server Components: Yes**
- **Component library: Base UI** (not Radix)

**Step 2: Add required components**

```bash
bunx shadcn@latest add card button badge chart
```

**Step 3: Verify build**

```bash
bun run build
```

Expected: Build succeeds.

**Step 4: Commit**

```bash
cd /Users/ethanwang/projects/devpulse
git add web/
git commit -m "feat(web): init shadcn/ui (Base UI) with card, button, badge, chart"
```

---

## Task 9: Dashboard page — summary cards + bar chart + activity timeline

**Files:**
- Modify: `web/src/lib/api.ts` (add activities + summaries endpoints)
- Create: `web/src/app/dashboard/page.tsx` (server component, fetches summaries)
- Create: `web/src/components/summary-cards.tsx`
- Create: `web/src/components/daily-chart.tsx`
- Create: `web/src/components/activity-timeline.tsx`
- Modify: `web/src/app/login/page.tsx` (redirect to /dashboard after login)

**Step 1: Extend API client**

Add to `web/src/lib/api.ts`:

```typescript
export interface ActivityResponse {
  id: number;
  source: string;
  type: string;
  payload: Record<string, unknown>;
  occurredAt: string;
}

export interface ActivitiesListResponse {
  activities: ActivityResponse[];
  total: number;
  page: number;
  perPage: number;
}

export interface SummaryResponse {
  date: string;
  totalCommits: number;
  totalPrs: number;
  codingMinutes: number;
}

export interface SummariesListResponse {
  summaries: SummaryResponse[];
}

// Add to api object:
activities: (params?: { page?: number; perPage?: number }) => {
  const searchParams = new URLSearchParams();
  if (params?.page) searchParams.set("page", String(params.page));
  if (params?.perPage) searchParams.set("per_page", String(params.perPage));
  const qs = searchParams.toString();
  return request<ActivitiesListResponse>(`/api/activities${qs ? `?${qs}` : ""}`);
},

summaries: (params?: { days?: number }) => {
  const searchParams = new URLSearchParams();
  if (params?.days) searchParams.set("days", String(params.days));
  const qs = searchParams.toString();
  return request<SummariesListResponse>(`/api/summaries${qs ? `?${qs}` : ""}`);
},
```

**Step 2: Create summary cards component**

Create `web/src/components/summary-cards.tsx`:

Uses shadcn `Card` component. Three cards in a row: Commits, PRs, Active Repos. Takes today's summary as props.

**Step 3: Create daily chart component**

Create `web/src/components/daily-chart.tsx`:

Uses shadcn `ChartContainer` + Recharts `BarChart`. X-axis: date, Y-axis: commit count. Takes 30-day summaries array as props.

**Step 4: Create activity timeline component**

Create `web/src/components/activity-timeline.tsx`:

Client component (`"use client"`). Fetches `/api/activities` with pagination. Each item shows: event type badge + description + repo name + relative time. "Load More" button at bottom.

**Step 5: Create dashboard page**

Create `web/src/app/dashboard/page.tsx`:

Client component that fetches summaries and renders summary cards + chart + timeline.

**Step 6: Update login redirect**

Modify `web/src/app/login/page.tsx`: Change `router.push("/")` to `router.push("/dashboard")`.

**Step 7: Verify build**

```bash
cd /Users/ethanwang/projects/devpulse/web
bun run build
```

Expected: Build succeeds with `/dashboard` route.

**Step 8: Commit**

```bash
cd /Users/ethanwang/projects/devpulse
git add web/
git commit -m "feat(web): add dashboard with summary cards, bar chart, and activity timeline"
```

---

Plan complete and saved to `docs/plans/2026-02-26-phase2-plan.md`. Execution options:

**1. Subagent-Driven (this session)** — I dispatch fresh subagent per task, review between tasks, fast iteration

**2. Parallel Session (separate)** — Open new session with executing-plans, batch execution with checkpoints

Which approach?
